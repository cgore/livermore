\subsection{Fundamental Operations}

Our representation of a time series and our approach to their evolutionary methods requires us to be capable of generating multi-dimensional raster paths, where a raster path is a one-dimensional path through a raster space.
This is so that we can run raster paths through a raster space of data, a discrete sampling of data.
A raster space is one that is representable by
$\mathbb{Z}_a \times \mathbb{Z}_b \times \cdots \times \mathbb{Z}_z$.
In other words, all of the dimensions are along sets of finite integers instead of the real numbers.
A common example is raster imagery: a two-dimensional bitmap of size $m \times n$ can be viewed as a complete representation of the two-dimensional raster space of $\mathbb{Z}_m \times \mathbb{Z}_n$.
A multidimensional matrix can therefore fully represent these spaces, instead of merely being samplings of the real space, although we are using these raster spaces for sampling of real data in our approach.
We form a useful sample of the data for further analysis and classification by TSC by generating paths through the data and it is these raster paths that the TSC actually classifies the situations with, not with the entire data set which is generally very large.
We will now outline the basic operations we use to generate raster lines.

\subsubsection{The \emph{Sort On} Algorithm}
\index{sort on algorithm@\emph{sort on} algorithm}
This algorithm sorts a sequence $s$ according to the ordering of another sequence $t$, and is outlined in Algorithm~\ref{alg:sort-on}.
\begin{algorithm}[H]
\caption{Sort on.}
\label{alg:sort-on}
\begin{algorithmic}[1]
\INPUT A sequence $s$ to be sorted.
\INPUT A sequence $t$ upon which to sort $s$ with.
\INPUT A comparator $c$ to sort with, typically $>$ or $<$.
\REQUIRE $|s| = n \le |t|$.
\STATE Construct a sequence $u$ containing pairs of the form $u_i = (s_i, t_i)$ as elements, $|u| = n$,
  \begin{equation}
  u = (u_0, \ldots, u_{n-1})
    = \left( (s_0, t_0), \ldots, (s_{n-1}, t_{n-1}) \right).
  \end{equation}
\STATE Sort $u$ using the second elements as the key, using any normal sorting algorithm, giving
  \begin{equation}
  u' = \left( (s'_0, t'_0), \ldots, (s'_{n-1}, t'_{n-1}) \right)
  \end{equation}
  where $t'_0 \le \ldots \le t'_{n-1}$ if we are sorting in ascending order (with the $<$ comparator).
\RETURN $s' = \left( s'_0, \ldots, s'_{n-1} \right)$.
\end{algorithmic}
\end{algorithm}

\subsubsection{The \emph{Sort Order} Algorithm}
\index{sort order algorithm@\emph{sort order} algorithm}
This algorithm returns the re-ordered indices of a sorted sequence, and is outlined in Algorithm~\ref{alg:sort-order}.
For example, if $t = \{4,5,3,9\}$
then the sorted ordering of $t$ would be $\{3,1,0,2\}$
since $t_3 \ge t_1 \ge t_0 \ge t_2$.
\begin{algorithm}[H]
\caption{Sort order.}
\label{alg:sort-order}
\begin{algorithmic}[1]
\INPUT A sequence $t$.
\INPUT A comparator $c$, usually $<$ or $>$.
\LETARROW{$n$} $|t|$.
\STATE Generate $\mathbb{Z}_n = (0, \ldots, n-1)$.
\RETURN The result of the \emph{sort on} algorithm from \S\ref{alg:sort-on} on $s = \mathbb{Z}_n$ with $t$ and the comparator $c$.
\end{algorithmic}
\end{algorithm}

%\subsubsection{The \emph{Map Inverse} Algorithm}
%\index{map inverse algorithm@\emph{map inverse} algorithm}
%This algorithm finds the inverse of a mapping, and is outlined in Algorithm~\ref{alg:map-inverse}.
%\begin{algorithm}[H]
%\caption{map inverse}
%\label{alg:map-inverse}
%\begin{algorithmic}[1]
%\INPUT A map $m \colon \mathbb{Z}_n \rightarrow \mathbb{Z}_n$, represented as a sequence.
%\STATE Validate that $m$ is a valid map.
%  Sort $m$ giving $m'$, and then remove any duplicates from $m'$ giving $m''$.
%  Check that $m'' = \mathbb{Z}_n$ where $n = |m|$.
%\RETURN $m^{-1}$, the inverse of $m$,
%  by calling the \emph{sort on} algorithm from \S\ref{alg:sort-on} with
%  $s = \mathbb{Z}_n$ and $t = m$.
%\end{algorithmic}
%\end{algorithm}

\subsubsection{Rasterized Linear Paths Through Arrays}
Given an array $A$ of rank $r$ and dimensions
$d_0 \times \cdots \times d_{r-1}$,
we wish to pull a one-dimensional list or vector $v$ of values from the array, starting at position
$A_{s_0\,\ldots\,s_{r-1}}$
and finishing at position
$A_{f_0\,\ldots\,f_{r-1}}$,
following a linear path through the array.

As an example consider the $4 \times 6$ array:
$$A = \left(\begin{array}{cccccc}
a & b & c & d & e & f \\
g & h & i & j & k & l \\
m & n & o & p & q & r \\
s & t & u & v & w & x
\end{array}\right).$$

\paragraph{A purely horizontal path.}
The linear path from $A_{0\,0}$ to $A_{0\,5}$ would be composed of the values
$$\left< A_{0\,0}, A_{0\,1}, A_{0\,2}, A_{0\,3}, A_{0\,4}, A_{0\,5} \right>$$
and would be
$$\left< a, b, c, d, e, f \right>$$
as illustrated by
$$A = \left(\begin{array}{cccccc}
\apmk a & \apmk b & \apmk c & \apmk d & \apmk e & \apmk f \\
g & h & i & j & k & l \\
m & n & o & p & q & r \\
s & t & u & v & w & x
\end{array}\right).$$

\paragraph{A purely vertical path.}
The linear path from $A_{0\,0}$ to $A_{3\,0}$ would be composed of the values
$$\left< A_{0\,0}, A_{1\,0}, A_{2\,0}, A_{3\,0} \right>$$
and would be
$$\left< a, g, m, s \right>$$
as illustrated by
$$A = \left(\begin{array}{cccccc}
\apmk a & b & c & d & e & f \\
\apmk g & h & i & j & k & l \\
\apmk m & n & o & p & q & r \\
\apmk s & t & u & v & w & x
\end{array}\right).$$

\paragraph{A traditional diagonal path.}
The linear path from $A_{0\,0}$ to $A_{3\,3}$ would be composed of the values
$$\left< A_{0\,0}, A_{1\,1}, A_{2\,2}, A_{3\,3} \right>$$
and would be
$$\left< a, h, o, v \right>$$
as illustrated by
$$A = \left(\begin{array}{cccccc}
\apmk a & b & c & d & e & f \\
g & \apmk h & i & j & k & l \\
m & n & \apmk o & p & q & r \\
s & t & u & \apmk v & w & x
\end{array}\right).$$

\paragraph{Non-equal diagonal paths.}
The confusing part arises when we are dealing with diagonal paths with unequal steps.
Consider the linear path from $A_{0\,0}$ to $A_{3\,5}$.
We end up with a stair-stepping path through the array:
$$\left(A_{0\,0}, A_{1\,1}, A_{2\,1}, A_{3\,2}, A_{4\,2}, A_{5\,3}\right)$$
and would be
$$\left(a, h, i, p, q, x\right)$$
as illustrated by
$$A = \left(\begin{array}{cccccc}
\apmk a & b & c & d & e & f \\
g & \apmk h & \apmk i & j & k & l \\
m & n & o & \apmk p & \apmk q & r \\
s & t & u & v & w & \apmk x
\end{array}\right).$$

\paragraph{The Raster Line Algorithm.}
This is the algorithm used to determine a linear raster path, and is outlined in Algorithm~\ref{alg:raster-line}.
It returns a list of points that follow the linear path from the starting point $p$ to the ending point $q$.
This is derived from the algorithm for raster conversion of a 3D line as described in \cite{KaufmanShimony1986}.
This should work for any dimensionality.
\begin{algorithm}[H]
\caption{Raster line.}
\label{alg:raster-line}
\begin{algorithmic}[1]
\INPUT a starting point $p$ and a final point $q$, both represented as lists.
\REQUIRE $|p| = |q| \land
   p_i \in \mathbb{N} \forall p_i \in p \land
   q_i \in \mathbb{N} \forall q_i \in q$.
\IF[This is a simple degenerate case.]{$p = q$}
  \RETURN $\{p\}$, a list containing only one element, $p$.
\ENDIF
\LETARROW{$n$} $|p| = |q|$ be the dimensionality.
\LETARROW{$\delta$} $\left\{ |p_0 - q_0|, \ldots, |p_{n-1} - q_{n-1}| \right\}$, $|\delta| = n$.
\LET $o$ be the sorted ordering of $\delta$ by $>$ from the \emph{sort order} algorithm in \S\ref{alg:sort-order}.
\LET $p'$ and $q'$ be $p$ and $q$ respectively, sorted according to $o$.
\IF[We want the starting point to have the lower initial dimension.]
   {$p'_0 \le q'_0$}
   \STATE Swap $p'$ with $q'$.
\ENDIF
\LETARROW{$\delta'$} $\left\{ |p'_0 - q'_0|, \ldots, |p'_{n-1} - q'_{n-1}| \right\}$.
\LETARROW{$s$} $\left( \sgn \left( p'_0 - q'_0 \right), \ldots,
   \sgn\left( p'_{n-1} - q'_{n-1} \right) \right)$,
    where $\sgn$ is the signum function.
\LETARROW{$d$} $\left\{ d_1, \ldots, d_{n-1} \right\}, |d| = n-1$,
   the deciders, where $d_i \leftarrow 2 \delta'_i - \delta'_0 \forall d_i \in d$.
\LETARROW{$a$} $\left\{ a_1, \ldots, a_{n-1} \right\}, |a| = n-1$, the if-increments, $a_i \leftarrow 2 \delta'_i \forall a_i \in a$.
\LETARROW{$b$} $\left\{ b_1, \ldots, b_{n-1} \right\}, |b| = n-1$, the else-increments, $b_i \leftarrow 2 \left( \delta'_i - \delta'_0 \right) \forall b_i \in b$.
\LETARROW{$r$} $\{ p' \}$, initializing the result of the algorithm, an ordered list of points.
\LETARROW{$z$} $p'$, initializing the current point.
\WHILE[After this, we have $r = \left\{ p', \ldots, q' \right\}$.]
  {$z_0 < q'_0$}
  \STATE Increment $z_0$ by 1.
  \FORALL{$d_i \in d$}
    \IF{$d_i < 0$}
      \STATE increment $d_i$ by $a_i$.
    \ELSE[In this case we have $d_i \ge 0$.]
      \STATE increment $d_i$ by $b_i$ and $z_i$ by $s_i$.
    \ENDIF
  \ENDFOR
  \STATE Push a duplicate of $z$ to the back of $r$, so that now $r = \left\{ p', \ldots, z \right\}$.
\ENDWHILE
\STATE  Reorder the coordinate of the points in $r$ according to the original coordinate ordering forming $r'$ by applying the inverse of $o$, which is $o$.
\IF{we originally swapped the start and end points}
  \RETURN the reverse of $r'$.
\ELSE
  \RETURN $r'$.
\ENDIF
\end{algorithmic}
\end{algorithm}

\subsubsection{List Slices}
This function returns a slice from a one-dimensional list; that is, a modular subset of the list, and is outlined in Algorithm~\ref{alg:list-slice}.
For example, a 2-slice of the list  $\{1,2,3,4,5,6,7,8,9\}$ would be the list $\{1,3,5,7,9\}$.
\begin{algorithm}[H]
\caption{List slice.}
\label{alg:list-slice}
\begin{algorithmic}[1]
\INPUT A list of elements $l = \{l_0, l_1, \ldots, l_{|l|}\}$.
\INPUT A positive rational slice size $s$.
\STATE Initialize the resulting list $r \leftarrow nil = \{\}$, initially empty.
\STATE Initialize the moving index $i \leftarrow 0$.
\WHILE{$i < |l|$}
  \IF{$i \in \mathbb{Z}$}
    \STATE Append $l_i$ to the end of $r$.
  \ENDIF
  \STATE $i \leftarrow i + s$.
\ENDWHILE
\RETURN $r$.
\end{algorithmic}
\end{algorithm}
